<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>记忆时光</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="描述">
<meta property="og:type" content="website">
<meta property="og:title" content="记忆时光">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="记忆时光">
<meta property="og:description" content="描述">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zhutongtong">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="记忆时光" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">记忆时光</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-计算机书籍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%A6%E7%B1%8D/" class="article-date">
  <time class="dt-published" datetime="2018-03-14T02:09:20.000Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%A6%E7%B1%8D/">计算机书籍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在高中时代凭着一腔热血，喜爱计算机，就学了计算机这一专业，到了之后发现并不是那么好，然尔事已至此，也不完全是坏，钻研技术，享受解决问题的快乐，剖析深处的秘密，还是挺好的。</p>
<h2 id="Thinking-in-java"><a href="#Thinking-in-java" class="headerlink" title="Thinking in java"></a>Thinking in java</h2><p><img src="http://7xpw00.com1.z0.glb.clouddn.com/thinkingInJava.jpg"></p>
<p>可以说是java方面的圣经书籍了。在学校学java的时候就买了这本书，当时是看不懂，翻了翻，至今也没看完，如今这本书早就丢了，也不想再买了。适合于中高级的java阅读，不适合初级，</p>
<p>看了30%  吸收10%</p>
<h2 id="JavaScript权威指南"><a href="#JavaScript权威指南" class="headerlink" title="JavaScript权威指南"></a>JavaScript权威指南</h2><p><img src="http://7xpw00.com1.z0.glb.clouddn.com/8d412ac52b8d166e00b1e39041d88c4d.jpg"></p>
<p>世人都说这本是javascript的经典之作，当时也在写js，所以就买了这本书看，自我感觉这本书一般，语言晦涩难懂，每一小节分的挺细致，理论知识也挺多的，但不符合我的风格，语言习惯</p>
<p>看了70% 吸收30%</p>
<h2 id="JavaScript高级程序设计"><a href="#JavaScript高级程序设计" class="headerlink" title="JavaScript高级程序设计"></a>JavaScript高级程序设计</h2><p><img src="http://7xpw00.com1.z0.glb.clouddn.com/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.jpg"></p>
<p>js的书就买了这两本，</p>
<h2 id="深入理解java虚拟机"><a href="#深入理解java虚拟机" class="headerlink" title="深入理解java虚拟机"></a>深入理解java虚拟机</h2><p><img src="http://7xpw00.com1.z0.glb.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA.jpg"></p>
<h2 id="Spring-实战"><a href="#Spring-实战" class="headerlink" title="Spring 实战"></a>Spring 实战</h2><p><img src="http://7xpw00.com1.z0.glb.clouddn.com/spring%20%E5%AE%9E%E6%88%98.jpg"></p>
<h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><p><img src="http://7xpw00.com1.z0.glb.clouddn.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.jpg"></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><img src="http://7xpw00.com1.z0.glb.clouddn.com/%E7%AE%97%E6%B3%95.jpg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%A6%E7%B1%8D/" data-id="cl4gp6u2z003w9cvc8eo565lk" data-title="计算机书籍" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB%E6%96%87%E5%8C%96%E4%B8%8E%E7%B4%A0%E5%85%BB/" rel="tag">生活文化与素养</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-一. Java内存区域与内存溢出异常" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/13/%E4%B8%80.%20Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/" class="article-date">
  <time class="dt-published" datetime="2018-03-13T14:59:22.000Z" itemprop="datePublished">2018-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/13/%E4%B8%80.%20Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/">一. Java内存区域与内存溢出异常</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一，数据区域"><a href="#一，数据区域" class="headerlink" title="一，数据区域"></a>一，数据区域</h2><p>java虚拟机在执行java程序的过程中会把它所管理 的内存分为若干个不同的<strong>数据区域</strong>。这些区域都有各自的<strong>用途</strong>，以及<strong>创建和销毁的时间</strong>，有的区域随着虚拟机进程的启动而存在。有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>一块较小的内存空间。可以理解为行号指示器，字节码解释器工作就是通过这个计数器的值来决定下一条执行的字节码指令，如分支，循环，跳转，异常处理，线程恢复等</p>
<p>由于java虚拟机的多线程是通过线程输液切换并分配处理器执行时间的方式来实现的，为了保证线程在切换的时候能恢复到正确的执行位置，每条线程都需要有一个独立 的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“<strong>线程私有</strong>”的内存</p>
<h3 id="2-java-虚拟机栈"><a href="#2-java-虚拟机栈" class="headerlink" title="2. java 虚拟机栈"></a>2. java 虚拟机栈</h3><p>java虚拟机栈也是<strong>线程私有</strong>的。生命周期和线程相同。虚拟机栈描述 的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储<strong>局部变量表</strong>，<strong>操作娄栈</strong>，<strong>动态链接</strong>，<strong>方法出口</strong>等。调用到执行的过程就是入栈到出栈的过程。</p>
<p>局部变量存放了各种数据类型（boolean,byte,char,short,int,float,long,double）,对象引用（reference类型）</p>
<p>其中64位长度的long 和double类型会占用2个局部变量空间，其他的占一个。当进入一个方法时，在帧中分配的局部变量空间是完全确定的。在方法运行期间不会改变局部变量表的大小。</p>
<p>这个区域规定了两种情况：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</li>
<li>如果虚拟机栈可以动态扩展。如果扩展时无法申请到足够的内存将会抛出OutOfMemoryError异常</li>
</ul>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>与虚拟机栈相似，区别是虚拟栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Naive方法服务。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</p>
<h3 id="4-java堆"><a href="#4-java堆" class="headerlink" title="4. java堆"></a>4. java堆</h3><p>是虚拟机所管理的内存中<strong>最大的一块内存</strong>。被所有<strong>线程共享</strong>，在虚拟机创建启动。目的是存放<strong>对象实例</strong>，几乎所有的对象实例都在这里分配内存。</p>
<p>java堆也是垃圾收集器管理的主要区域，也被称为 GC 堆，从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以java堆还可细分为:新生代和老年代，再细致一点的有Eden空间，From Survivor空间，ToSurvivor空间等。从内存分配还可划分出多个线程私有的分配缓冲区</p>
<p>java堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可，</p>
<p>当前主流的虚拟机都是按照可扩展来实现的，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常</p>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>与java堆一样，线程共享的区域。用于存储已被虚拟机加载的<strong>类信息</strong>，<strong>常量</strong>，<strong>静态变量</strong>，<strong>即时编译器编译后的代码</strong>等数据。</p>
<p>很多人习惯把方法区称为”永久代”，两者本质上并不等价。</p>
<p>当方法区无法满足内存分配的需求时，将抛出OutOfMemoryError异常</p>
<h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h3><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本，字段，方法接口等描述信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用。java虚拟机对Class文件的每一部分都严格规定，但对于运行时常量池，没有做任何细节的要求。</p>
<p>运行时常量池是方法区的一部分，自然也受到方法区内存的限制，当常量池无法申请到内存时会抛出OutMemoryError异常</p>
<h3 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/13/%E4%B8%80.%20Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/" data-id="cl4gp6u2c002j9cvc3h8k4jlf" data-title="一. Java内存区域与内存溢出异常" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">java虚拟机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-二.  java集合源码解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/13/%E4%BA%8C.%20%20java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2018-03-13T03:01:59.000Z" itemprop="datePublished">2018-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/13/%E4%BA%8C.%20%20java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">二. java集合源码解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、ArrayList数据结构"><a href="#一、ArrayList数据结构" class="headerlink" title="一、ArrayList数据结构"></a>一、ArrayList数据结构</h2><p>分析一个类的时候，数据结构往往是它的灵魂所在，理解底层的数据结构其实就理解了该类的实现思路，具体的实现细节再具体分析。</p>
<p>　　ArrayList的数据结构如下：</p>
<pre><code> 1 2 3 4 5 6 7 8 
| | | | | | | | |
</code></pre>
<p>说明：底层的数据结构就是数组，数组元素类型为Object类型，即可以存放所有类型数据。我们对ArrayList类的实例的所有的操作底层都是基于数组的。下面我们来分析通过数组是如何保证库函数的正确实现的。</p>
<h2 id="二、ArrayList源码分析"><a href="#二、ArrayList源码分析" class="headerlink" title="二、ArrayList源码分析"></a>二、ArrayList源码分析</h2><h3 id="2-1-类的继承关系"><a href="#2-1-类的继承关系" class="headerlink" title="2.1 类的继承关系"></a>2.1 类的继承关系</h3><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; 
implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
</code></pre>
<p>说明：ArrayList继承AbstractList抽象父类，实现了List接口（规定了List的操作规范）、RandomAccess（可随机访问）、Cloneable（可拷贝）、Serializable（可序列化）。</p>
<h3 id="2-2-类的属性"><a href="#2-2-类的属性" class="headerlink" title="2.2 类的属性"></a>2.2 类的属性</h3><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
&#123;
    // 版本号
    private static final long serialVersionUID = 8683452581122892189L;
    // 缺省容量
    private static final int DEFAULT_CAPACITY = 10;
    // 空对象数组
    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;
    // 缺省空对象数组
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;
    // 元素数组
    transient Object[] elementData;
    // 实际元素大小，默认为0
    private int size;
    // 最大数组容量
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
&#125;
</code></pre>
<p>说明：类的属性中核心的属性为elementData，类型为Object[]，用于存放实际元素，并且被标记为transient，也就意味着在序列化的时候，此字段是不会被序列化的。</p>
<h3 id="2-3-类的构造函数"><a href="#2-3-类的构造函数" class="headerlink" title="2.3 类的构造函数"></a>2.3 类的构造函数</h3><h4 id="ArrayList-int-型构造函数"><a href="#ArrayList-int-型构造函数" class="headerlink" title="ArrayList(int)型构造函数"></a>ArrayList(int)型构造函数</h4><pre><code>public ArrayList(int initialCapacity) &#123;
    if (initialCapacity &gt; 0) &#123; // 初始容量大于0
        this.elementData = new Object[initialCapacity]; // 初始化元素数组
    &#125; else if (initialCapacity == 0) &#123; // 初始容量为0
        this.elementData = EMPTY_ELEMENTDATA; // 为空对象数组
    &#125; else &#123; // 初始容量小于0，抛出异常
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    &#125;
&#125;
</code></pre>
<p>说明：指定elementData数组的大小，不允许初始化大小小于0，否则抛出异常。</p>
<h4 id="ArrayList-型构造函数"><a href="#ArrayList-型构造函数" class="headerlink" title="ArrayList()型构造函数"></a>ArrayList()型构造函数</h4><pre><code>public ArrayList() &#123; 
    // 无参构造函数，设置元素数组为空 
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
&#125;
</code></pre>
<p>说明：当未指定初始化大小时，会给elementData赋值为空集合。</p>
<h4 id="ArrayList-Collection-lt-extends-E-gt-型构造函数"><a href="#ArrayList-Collection-lt-extends-E-gt-型构造函数" class="headerlink" title="ArrayList(Collection&lt;? extends E&gt;)型构造函数"></a>ArrayList(Collection&lt;? extends E&gt;)型构造函数</h4><pre><code>public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 集合参数构造函数
    elementData = c.toArray(); // 转化为数组
    if ((size = elementData.length) != 0) &#123; // 参数为非空集合
        if (elementData.getClass() != Object[].class) // 是否成功转化为Object类型数组
            elementData = Arrays.copyOf(elementData, size, Object[].class); // 不为Object数组的话就进行复制
    &#125; else &#123; // 集合大小为空，则设置元素数组为空
        this.elementData = EMPTY_ELEMENTDATA;
    &#125;
&#125;
</code></pre>
<p>说明：当传递的参数为集合类型时，会把集合类型转化为数组类型，并赋值给elementData。</p>
<h3 id="2-4-核心函数分析"><a href="#2-4-核心函数分析" class="headerlink" title="2.4 核心函数分析"></a>2.4 核心函数分析</h3><h4 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h4><pre><code> public boolean add(E e) &#123; // 添加元素
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
&#125;
</code></pre>
<p>说明：在add函数我们发现还有其他的函数ensureCapacityInternal，此函数可以理解为确保elementData数组有合适的大小。ensureCapacityInternal的具体函数如下</p>
<pre><code>private void ensureCapacityInternal(int minCapacity) &#123;
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 判断元素数组是否为空数组
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // 取较大值
    &#125;
   
    ensureExplicitCapacity(minCapacity);
&#125;
</code></pre>
<p>说明：在ensureCapacityInternal函数中我们又发现了ensureExplicitCapacity函数，这个函数也是为了确保elemenData数组有合适的大小。ensureExplicitCapacity的具体函数如下</p>
<pre><code>private void ensureExplicitCapacity(int minCapacity) &#123;
    // 结构性修改加1
    modCount++;
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
&#125;
</code></pre>
<p>说明：在ensureExplicitCapacity函数我们又发现了grow函数，grow函数才会对数组进行扩容，ensureCapacityInternal、ensureExplicitCapacity都只是过程，最后完成实际扩容操作还是得看grow函数，grow函数的具体函数如下　</p>
<pre><code>private void grow(int minCapacity) &#123;
    int oldCapacity = elementData.length; // 旧容量
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 新容量为旧容量的1.5倍
    if (newCapacity - minCapacity &lt; 0) // 新容量小于参数指定容量，修改新容量
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 新容量大于最大容量
        newCapacity = hugeCapacity(minCapacity); // 指定新容量
    // 拷贝扩容
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;
</code></pre>
<p>说明：正常情况下会扩容1.5倍，特殊情况下（新扩展数组大小已经达到了最大值）则只取最大值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/13/%E4%BA%8C.%20%20java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" data-id="cl4gp6u2o002v9cvc22y554lz" data-title="二. java集合源码解析" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-一.  java集合基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/12/%E4%B8%80.%20%20java%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2018-03-12T02:54:25.000Z" itemprop="datePublished">2018-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/12/%E4%B8%80.%20%20java%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">一. java集合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/leeplogs/p/5891861.html" title="原文地址">https://www.cnblogs.com/leeplogs/p/5891861.html</a>这个总结的还是挺好的，拿来用下下。</p>
<h2 id="一-集合与数组"><a href="#一-集合与数组" class="headerlink" title="一. 集合与数组"></a>一. 集合与数组</h2><ul>
<li>数组（可以存储基本数据类型）是用来存现对象的一种容器，但是数组的长度固定，不适合在对象数量未知的情况下使用。</li>
<li>集合（只能存储对象，对象类型可以不一样）的长度可变，可在多数情况下使用。</li>
</ul>
<h2 id="二-层次关系"><a href="#二-层次关系" class="headerlink" title="二. 层次关系"></a>二. 层次关系</h2><p>如图所示: 图中，实线边框的是实现类，折线边框的是抽象类，而点线边框的是接口</p>
<p><img src="http://7xpw00.com1.z0.glb.clouddn.com/875181-20160921100733106-1187286566.png"></p>
<p><strong>Collection接口</strong>是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是Set和List。<strong>Set中不能包含重复的元素</strong>。<strong>List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式</strong>。</p>
<p><strong>Map</strong>是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。<strong>Map不能包含重复的key，但是可以包含相同的value。</strong></p>
<p><strong>Iterator</strong>，所有的集合类，都实现了Iterator接口，这是一个用于遍历集合中元素的接口，主要包含以下三种方法：</p>
<ol>
<li>hasNext()是否还有下一个元素。</li>
<li>next()返回下一个元素。</li>
<li>remove()删除当前元素。</li>
</ol>
<h2 id="三-几种重要的接口和类简介"><a href="#三-几种重要的接口和类简介" class="headerlink" title="三. 几种重要的接口和类简介"></a>三. 几种重要的接口和类简介</h2><p><strong>1、List（有序、可重复）</strong></p>
<p>List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。</p>
<p><strong>2、Set（无序、不能重复）</strong></p>
<p>Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。TreeSet有序(二叉树排序)</p>
<p><strong>3、Map（键值对、键唯一、值不唯一）</strong></p>
<p>Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。TreeMap有序(二叉排序树)</p>
<h2 id="四-遍历"><a href="#四-遍历" class="headerlink" title="四. 遍历"></a>四. 遍历</h2><p>在类集中提供了以下四种的常见输出方式: </p>
<p>1）Iterator：迭代输出，是使用最多的输出方式。</p>
<p>2）ListIterator：是Iterator的子接口，专门用于输出List中的内容。</p>
<p>3）foreach输出：JDK1.5之后提供的新功能，可以输出数组或集合。</p>
<p>4）for循环</p>
<p>代码示例如下：</p>
<p> for的形式：for（int i&#x3D;0;i&lt;arr.size();i++）{…}</p>
<p> foreach的形式： for（int　i：arr）{…}</p>
<p> iterator的形式：<br>Iterator it &#x3D; arr.iterator();<br>while(it.hasNext()){ object o &#x3D;it.next(); …}</p>
<h2 id="五-ArrayList和LinkedList"><a href="#五-ArrayList和LinkedList" class="headerlink" title="五. ArrayList和LinkedList"></a>五. ArrayList和LinkedList</h2><p>ArrayList和LinkedList在用法上没有区别，但是在功能上还是有区别的。LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反。</p>
<h2 id="六-Map集合"><a href="#六-Map集合" class="headerlink" title="六. Map集合"></a>六. Map集合</h2><p>实现类：HashMap、Hashtable、LinkedHashMap和TreeMap</p>
<p><strong>HashMap</strong></p>
<p>HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的</p>
<p><strong>Hashtable</strong></p>
<p>Hashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。</p>
<p><strong>ConcurrentHashMap</strong></p>
<p>线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<p><strong>LinkedHashMap</strong></p>
<p>LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。</p>
<p><strong>TreeMap</strong></p>
<p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的；</p>
<p><strong>map的遍历</strong></p>
<p>第一种：KeySet()<br>将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。<br>keySet():迭代后只能通过get()取key 。取到的结果会乱序，是因为取得数据行主键的时候，使用了HashMap.keySet()方法，而这个方法返回的Set结果，里面的数据是乱序排放的。<br>典型用法如下：</p>
<pre><code>Map map = new HashMap();
map.put(&quot;key1&quot;,&quot;lisi1&quot;);
map.put(&quot;key2&quot;,&quot;lisi2&quot;);
map.put(&quot;key3&quot;,&quot;lisi3&quot;);
map.put(&quot;key4&quot;,&quot;lisi4&quot;);  
//先获取map集合的所有键的set集合，keyset（）
Iterator it = map.keySet().iterator();
 //获取迭代器
while(it.hasNext())&#123;
Object key = it.next();
System.out.println(map.get(key));
&#125;
</code></pre>
<p>第二种：entrySet（）</p>
<p>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#x2F;&#x2F;返回此映射中包含的映射关系的 Set 视图。（一个关系就是一个键-值对），就是把(key-value)作为一个整体一对一对地存放到Set集合当中的。Map.Entry表示映射关系。entrySet()：迭代后可以e.getKey()，e.getValue()两种方法来取key和value。返回的是Entry接口。<br>典型用法如下：</p>
<pre><code>Map map = new HashMap();
map.put(&quot;key1&quot;,&quot;lisi1&quot;);
map.put(&quot;key2&quot;,&quot;lisi2&quot;);
map.put(&quot;key3&quot;,&quot;lisi3&quot;);
map.put(&quot;key4&quot;,&quot;lisi4&quot;);
//将map集合中的映射关系取出，存入到set集合
Iterator it = map.entrySet().iterator();
while(it.hasNext())&#123;
Entry e =(Entry) it.next();
System.out.println(&quot;键&quot;+e.getKey () + &quot;的值为&quot; + e.getValue());
&#125;
</code></pre>
<p>推荐使用第二种方式，即entrySet()方法，效率较高。<br>对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。两种遍历的遍历时间相差还是很明显的。</p>
<h2 id="七-主要实现类区别小结"><a href="#七-主要实现类区别小结" class="headerlink" title="七. 主要实现类区别小结"></a>七. 主要实现类区别小结</h2><h3 id="Vector和ArrayList"><a href="#Vector和ArrayList" class="headerlink" title="Vector和ArrayList"></a>Vector和ArrayList</h3><ol>
<li>vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。    </li>
<li>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。</li>
<li>如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。<br>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。</li>
</ol>
<h3 id="arraylist和linkedlist"><a href="#arraylist和linkedlist" class="headerlink" title="arraylist和linkedlist"></a>arraylist和linkedlist</h3><ol>
<li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li>
<li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li>
<li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</li>
</ol>
<h3 id="HashMap与TreeMap"><a href="#HashMap与TreeMap" class="headerlink" title="HashMap与TreeMap"></a>HashMap与TreeMap</h3><ol>
<li>HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</li>
<li>在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。<br>两个map中的元素一样，但顺序不一样，导致hashCode()不一样。<br>同样做测试：<br>在HashMap中，同样的值的map,顺序不同，equals时，false;<br>而在treeMap中，同样的值的map,顺序不同,equals时，true，说明，treeMap在equals()时是整理了顺序了的。</li>
</ol>
<h3 id="HashTable与HashMap"><a href="#HashTable与HashMap" class="headerlink" title="HashTable与HashMap"></a>HashTable与HashMap</h3><ol>
<li>同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。</li>
<li>HashMap允许存在一个为null的key，多个为null的value 。</li>
<li>hashtable的key和value都不允许为null。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/12/%E4%B8%80.%20%20java%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="cl4gp6u2k002l9cvc0ygrdh3m" data-title="一. java集合" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-spring REST之 RestTemplate的使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/08/spring%20REST%E4%B9%8B%20RestTemplate%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2018-03-08T03:28:23.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/08/spring%20REST%E4%B9%8B%20RestTemplate%E7%9A%84%E4%BD%BF%E7%94%A8/">spring REST之 RestTemplate的使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h2><p>REST就是将资源的状态以最适合客户端或服务端的形式从服务器端转移到客户端（或者反过来）</p>
<p>在REST中是通过URL进行识别一定位。是通过HTTP方法来定义。也就是GET,POST，PUT，DELETE，PATCH等。这些HTTP方法通常会匹配如下的CRUD操作。</p>
<ul>
<li>Create:POST</li>
<li>Read: GET</li>
<li>Update: PUT或PATCH</li>
<li>Delete： Delete</li>
</ul>
<h2 id="二-基本使用"><a href="#二-基本使用" class="headerlink" title="二. 基本使用"></a>二. 基本使用</h2><p>在RestTemplate提供了对应于每个的六个主要的HTTP方法</p>
<p>表1. RestTemplate方法的概述</p>
<p>RestTemplate定义了36个与REST资源交互的方法，其中的大多数都对应于HTTP的方法。<br>其实，这里面只有11个独立的方法，其中有十个有三种重载形式，而第十一个则重载了六次，这样一共形成了36个方法</p>
<ul>
<li>delete() 在特定的URL上对资源执行HTTP DELETE操作</li>
<li>exchange() 在URL上执行特定的HTTP方法，返回包含对象的ResponseEntity，这个对象是从响应体中映射得到的</li>
<li>execute() 在URL上执行特定的HTTP方法，返回一个从响应体映射得到的对象</li>
<li><strong>getForEntity()</strong> 发送一个HTTP GET请求，返回的ResponseEntity包含了响应体所映射成的对象</li>
<li><strong>getForObject()</strong> 发送一个HTTP GET请求，返回的请求体将映射为一个对象</li>
<li><strong>postForEntity()</strong>  POST 数据到一个URL，返回包含一个对象的ResponseEntity，这个对象是从响应体中映射得到的</li>
<li><strong>postForObject()</strong> POST 数据到一个URL，返回根据响应体匹配形成的对象</li>
<li>headForHeaders() 发送HTTP HEAD请求，返回包含特定资源URL的HTTP头</li>
<li>optionsForAllow() 发送HTTP OPTIONS请求，返回对特定URL的Allow头信息</li>
<li>postForLocation() POST 数据到一个URL，返回新创建资源的URL</li>
<li>put() PUT 资源到特定的URL</li>
</ul>
<h2 id="Rest服务-模拟提供Rest数据"><a href="#Rest服务-模拟提供Rest数据" class="headerlink" title="Rest服务,模拟提供Rest数据"></a>Rest服务,模拟提供Rest数据</h2><pre><code>@RestController
public class DataController &#123;
    @RequestMapping(value = &quot;getAll&quot;)
    public List&lt;UserEntity&gt; getUser() &#123;
        List&lt;UserEntity&gt; list = new ArrayList&lt;&gt;();
        list.add(new UserEntity(&quot;zhangsan&quot;,&quot;123456&quot;,&quot;man&quot;));
        list.add(new UserEntity(&quot;lisi&quot;,&quot;321654&quot;,&quot;woman&quot;));
        list.add(new UserEntity(&quot;wangfer&quot;,&quot;741258&quot;,&quot;man&quot;));
        return list;
    &#125;

    @RequestMapping(&quot;get/&#123;id&#125;&quot;)
    public UserEntity getById(@PathVariable(name = &quot;id&quot;) String id) &#123;
        UserEntity userEntity = new UserEntity(&quot;zhangsan&quot;, &quot;34524&quot;, &quot;man&quot;);
        return userEntity;
    &#125;

    @RequestMapping(value = &quot;save&quot;)
    public String save(UserEntity userEntity) &#123;
        return userEntity.toString()+&quot;保存成功&quot;;
    &#125;

    @RequestMapping(value = &quot;saveByType/&#123;type&#125;&quot;)
    public String saveByType(UserEntity userEntity,@PathVariable(&quot;type&quot;)String type) &#123;
        return &quot;保存成功,type=&quot;+type;
    &#125;
&#125;
</code></pre>
<h2 id="1-GET请求"><a href="#1-GET请求" class="headerlink" title="1. GET请求"></a>1. GET请求</h2><h3 id="1-getForEntity使用方法"><a href="#1-getForEntity使用方法" class="headerlink" title="(1)getForEntity使用方法"></a>(1)getForEntity使用方法</h3><p>无参数的getForEntity</p>
<pre><code>@RequestMapping(&quot;getForEntity&quot;)
public List&lt;UserEntity&gt; getAll2() &#123;
    ResponseEntity&lt;List&gt; responseEntity = restTemplate.getForEntity(&quot;http://localhost:8080/getAll&quot;, List.class);
    HttpHeaders headers = responseEntity.getHeaders();
    HttpStatus statusCode = responseEntity.getStatusCode();
    int code = statusCode.value();
    List&lt;UserEntity&gt; list = responseEntity.getBody();
    System.out.println(list.toString());
    return list;

&#125;
</code></pre>
<p>有参数的 getForEntity 请求,参数列表 如下才是参数的正确使用方式,曾在这踩了一个坑,浪费了好长时间,</p>
<pre><code>@RequestMapping(&quot;getForEntity/&#123;id&#125;&quot;)
public UserEntity getById2(@PathVariable(name = &quot;id&quot;) String id) &#123;
    String url = &quot;http://localhost:8080/get/&#123;id&#125;?username=&#123;username&#125;&amp;password=&#123;password&#125;&amp;sex=&#123;sex&#125;&quot;;
    Map&lt;String,String&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;id&quot;,&quot;11&quot;);
    map.put(&quot;username&quot;,&quot;lisi&quot;);
    map.put(&quot;password&quot;,&quot;12345&quot;);
    map.put(&quot;sex&quot;,&quot;man&quot;);
    ResponseEntity&lt;UserEntity&gt; responseEntity = restTemplate.getForEntity(url, UserEntity.class, map );
    UserEntity userEntity = responseEntity.getBody();
    return userEntity;
&#125;
</code></pre>
<blockquote>
<p>但是,通常情况下我们并不想要Http请求的全部信息,只需要相应体即可.对于这种情况,RestTemplate提供了 getForObject() 方法用来只获取 响应体信息.<br>getForObject 和 getForEntity 用法几乎相同,指示返回值返回的是 响应体,省去了我们 再去 getBody() </p>
</blockquote>
<h3 id="2-getForObject使用方法"><a href="#2-getForObject使用方法" class="headerlink" title="(2)getForObject使用方法"></a>(2)getForObject使用方法</h3><p>无参数的getForEntity</p>
<pre><code>@RequestMapping(&quot;getAll2&quot;)
public List&lt;UserEntity&gt; getAll() &#123;
    List&lt;UserEntity&gt; list = restTemplate.getForObject(&quot;http://localhost:8080/getAll&quot;, List.class);
    System.out.println(list.toString());
    return list;
&#125;
</code></pre>
<p>有参数的 get 请求,使用map封装请求参数</p>
<pre><code>@RequestMapping(&quot;get3/&#123;id&#125;&quot;)
public UserEntity getById3(@PathVariable(name = &quot;id&quot;) String id) &#123;
    HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;id&quot;,id);
    UserEntity userEntity = restTemplate.getForObject(&quot;http://localhost:8080/get/&#123;id&#125;&quot;, UserEntity.class, map);
    return userEntity;
&#125;
</code></pre>
<h2 id="2-Post请求"><a href="#2-Post请求" class="headerlink" title="2. Post请求"></a>2. Post请求</h2><p>post 请求,提交 UserEntity 对像</p>
<pre><code>@RequestMapping(&quot;saveUser&quot;)
public String save(UserEntity userEntity) &#123;
    ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(&quot;http://localhost:8080/save&quot;, userEntity, String.class);
    String body = responseEntity.getBody();
    return body;
&#125;
</code></pre>
<p>有参数的 postForEntity 请求,使用map封装</p>
<pre><code>@RequestMapping(&quot;saveUserByType2/&#123;type&#125;&quot;)
public String save3(UserEntity userEntity,@PathVariable(&quot;type&quot;)String type) &#123;
    HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;type&quot;, type);
    ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(&quot;http://localhost:8080/saveByType/&#123;type&#125;&quot;, userEntity, String.class,map);
    String body = responseEntity.getBody();
    return body;
&#125;
</code></pre>
<p>以上get 和post 两个 请求基本上可以满足我们的大部分需求,如果不满足可以使用 **exchange()**或者 <strong>execute()</strong> 来实现,通过看源代码,可以发现,getForEntity() 和postForEntity()是对这两个方法的封装.</p>
<h2 id="三-手动指定转换器-HttpMessageConverter"><a href="#三-手动指定转换器-HttpMessageConverter" class="headerlink" title="三. 手动指定转换器(HttpMessageConverter)"></a>三. 手动指定转换器(HttpMessageConverter)</h2><p>我们知道 ,reseful接口传递的数据内容和响应都是json格式的字符串.而postForObject方法请求和返回的参数都是java类,是RestTemplate通过HttpMessageConverter帮我们做了转换的操作.</p>
<p>通过查看restTemplate实例对象,</p>
<p><img src="http://7xpw00.com1.z0.glb.clouddn.com/restTemplateObject.png"></p>
<p>默认情况下RestTemplate自动帮我们注册了一组HttpMessageConverter用来处理一些不同的contextType的请求.如:</p>
<ul>
<li>StringHttpMessageConverter来处理text&#x2F;plain; </li>
<li>MappingJackson2HttpMessageConverter来处理application&#x2F;json;</li>
<li>Jaxb2RootElementHttpMessageConverter来处理application&#x2F;xml,text&#x2F;xml。</li>
<li>AllEncompassingFormHttpMessageConverter来处理application&#x2F;x-www-form-urlencoded。</li>
</ul>
<p>这些可满足大部分的需求,如果这些都不能满足.你可以实现org.springframework.http.converter.HttpMessageConverter接口自己写一个。详情参考官方api。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/08/spring%20REST%E4%B9%8B%20RestTemplate%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="cl4gp6u2a002c9cvc1qhg95jd" data-title="spring REST之 RestTemplate的使用" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Http解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/05/Http%E8%A7%A3%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2018-03-05T13:13:33.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/05/Http%E8%A7%A3%E6%9E%90/">HTTP解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一直对请求响应不太明白，做下总结，分析。原理机制先不说了，先对用法，注意事项做下梳理</p>
<h2 id="一-HTTP-无状态性"><a href="#一-HTTP-无状态性" class="headerlink" title="一. HTTP 无状态性"></a>一. HTTP 无状态性</h2><p>HTTP 协议是无状态的(stateless)。也就是说，同一个客户端第二次访问同一个服务器上的页面时，服务器无法知道这个客户端曾经访问过，服务器也无法分辨不同的客户端。HTTP 的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的HTTP 请求。</p>
<h2 id="二-HTTP-持久连接"><a href="#二-HTTP-持久连接" class="headerlink" title="二. HTTP 持久连接"></a>二. HTTP 持久连接</h2><p>HTTP1.0 使用的是非持久连接，主要缺点是客户端必须为每一个待请求的对象建立并维护一个新的连接，即每请求一个文档就要有两倍RTT 的开销。因为同一个页面可能存在多个对象，所以非持久连接可能使一个页面的下载变得十分缓慢，而且这种短连接增加了网络传输的负担。HTTP1.1 使用持久连接keepalive，所谓持久连接，就是服务器在发送响应后仍然在一段时间内保持这条连接，允许在同一个连接中存在多次数据请求和响应，即在持久连接情况下，服务器在发送完响应后并不关闭TCP 连接，而客户端可以通过这个连接继续请求其他对象。</p>
<h3 id="1-HTTP-x2F-1-1-协议的持久连接有两种方式："><a href="#1-HTTP-x2F-1-1-协议的持久连接有两种方式：" class="headerlink" title="1. HTTP&#x2F;1.1 协议的持久连接有两种方式："></a>1. HTTP&#x2F;1.1 协议的持久连接有两种方式：</h3><ol>
<li>非流水线方式：客户在收到前一个响应后才能发出下一个请求;</li>
<li>流水线方式：客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文;</li>
</ol>
<h2 id="三-常见的HTTP请求头"><a href="#三-常见的HTTP请求头" class="headerlink" title="三. 常见的HTTP请求头"></a>三. 常见的HTTP请求头</h2><ul>
<li>Accept-Charset		用于指定客户端接受的字符集</li>
<li>Accept-Encoding   用于指定可接受的内容编码</li>
<li>Accept-Language	用于指定一种自然语言，</li>
<li>Host 	用户指定被请求资源的Internet主机和端口号</li>
<li>User-Agent 	客户端将它的操作系统，浏览器和其他属性告诉服务器</li>
<li>Connection	当前连接是否保持</li>
</ul>
<h2 id="四-常见的HTTP响应头"><a href="#四-常见的HTTP响应头" class="headerlink" title="四. 常见的HTTP响应头"></a>四. 常见的HTTP响应头</h2><ul>
<li>Server 	使用的服务器名称 </li>
<li>Content-Type 	用来指明发送给接收者的实体正文的媒体类型。如Content-Type:text&#x2F;html:charset&#x3D;GBK</li>
<li>Content-Encoding	与请求报头Accept-Encoding对应，告诉浏览器服务端采用的是什么压缩编码</li>
<li>Content-Language 描述了资源所有的自然语言，与Accent-Language 相对应 </li>
<li>Content-Length 指明实体正文的长度，用以字节方式存储的十进制数字来表示</li>
<li>Keep-Alive	保持连接的时间</li>
</ul>
<h2 id="五-常见的HTTP状态码"><a href="#五-常见的HTTP状态码" class="headerlink" title="五. 常见的HTTP状态码"></a>五. 常见的HTTP状态码</h2><ul>
<li>200 请求已成功，请求所希望的响应头或数据体将随此响应返回。</li>
<li>302 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。</li>
<li>400 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。</li>
<li>403 服务器已经理解请求，但是拒绝执行它</li>
<li>404 请求失败，请求所希望得到的资源未被在服务器上发现。</li>
<li>500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现</li>
</ul>
<h2 id="六-HTTP请求信息由3部分组成"><a href="#六-HTTP请求信息由3部分组成" class="headerlink" title="六. HTTP请求信息由3部分组成"></a>六. HTTP请求信息由3部分组成</h2><ol>
<li>请求方法（GET&#x2F;POST）、URI、协议&#x2F;版本</li>
<li>请求头(Request Header)</li>
<li>请求正文</li>
</ol>
<p>以上图做例进行分析：</p>
<pre><code>POST http://xg.mediportal.com.cn/health/sms/verify/telephone HTTP/1.1

User-Agent: DGroupPatient/1.052701.230/Dalvik/2.1.0 (Linux; U; Android 5.1.1; KIW-AL10 Build/HONORKIW-AL10)
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Host: xg.mediportal.com.cn
Connection: Keep-Alive
Accept-Encoding: gzip
Content-Length: 33

username=zhangsan&amp;password=admin
</code></pre>
<h3 id="1-请求方法、URI、协议-x2F-版本"><a href="#1-请求方法、URI、协议-x2F-版本" class="headerlink" title="1.请求方法、URI、协议&#x2F;版本"></a>1.请求方法、URI、协议&#x2F;版本</h3><p>请求的第一行是“方法、URL、协议&#x2F;版本”<br>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>例如：HTTP1.1目前支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。</p>
<ul>
<li>GET 请求获取由Request-URI所标识的资源</li>
<li>POST 在Request-URI所标识的资源后附加新的数据</li>
<li>HEAD 请求获取由Request-URI所标识的资源的响应消息报头</li>
<li>OPTIONS 请求查询服务器的性能，或查询与资源相关的选项和需求</li>
<li>PUT 请求服务器存储一个资源，并用Request-URI作为其标识</li>
<li>DELETE 请求服务器删除由Request-URI	所标识的资源</li>
<li>TRACE 请求服务器回送收到的请求信息，主要用语测试或诊断</li>
</ul>
<h3 id="2-请求头"><a href="#2-请求头" class="headerlink" title="2.请求头"></a>2.请求头</h3><ul>
<li>Content-Type 内容类型，专业术语叫“媒体类型”，即MediaType，也叫MIME类型，用来指明报文主体部分内容属于何种类型。</li>
</ul>
<blockquote>
<p>但是content-type一般只存在于Post方法中，因为Get方法是不含“body”的，它的请求参数都会被编码到url后面，所以在Get方法中加Content-type是无用的。</p>
</blockquote>
<p>常见的<strong>MIME类型</strong>如下：</p>
<ul>
<li>text&#x2F;html ： HTML格式</li>
<li>text&#x2F;plain ：纯文本格式      </li>
<li>text&#x2F;xml ：  XML格式</li>
<li>image&#x2F;gif ：gif图片格式    </li>
<li>image&#x2F;jpeg ：jpg图片格式 </li>
<li>image&#x2F;png：png图片格式</li>
</ul>
<p>以application开头的媒体格式类型：</p>
<ul>
<li>application&#x2F;xhtml+xml ：XHTML格式</li>
<li>application&#x2F;xml     ： XML数据格式</li>
<li>application&#x2F;atom+xml  ：Atom XML聚合格式    </li>
<li>application&#x2F;json    ： JSON数据格式</li>
<li>application&#x2F;pdf       ：pdf格式  </li>
<li>application&#x2F;msword  ： Word文档格式</li>
<li>application&#x2F;octet-stream ： 二进制流数据（如常见的文件下载）</li>
<li>application&#x2F;x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据的格式）</li>
</ul>
<p>另外一种常见的媒体格式是上传文件之时使用的：</p>
<ul>
<li>multipart&#x2F;form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li>
</ul>
<h3 id="3-请求正文"><a href="#3-请求正文" class="headerlink" title="3. 请求正文"></a>3. 请求正文</h3><p>请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：</p>
<pre><code>telephone=15527177736&amp;userType=1&amp;
</code></pre>
<h2 id="七-HTTP响应格式"><a href="#七-HTTP响应格式" class="headerlink" title="七. HTTP响应格式"></a>七. HTTP响应格式</h2><p>HTTP应答与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p>
<ol>
<li><p>状态行</p>
</li>
<li><p>响应头(Response Header)</p>
</li>
<li><p>响应正文</p>
<p>HTTP&#x2F;1.1 200 OK   &#x2F;&#x2F;状态行<br>Server: nginx<br>Date: Tue, 31 May 2016 02:09:24 GMT<br>Content-Type: application&#x2F;json;charset&#x3D;UTF-8<br>Connection: keep-alive<br>Vary: Accept-Encoding<br>Access-Control-Allow-Origin: *<br>Access-Control-Allow-Headers: X-Requested-With,access_token,access-token,content-type,multipart&#x2F;form-data,application&#x2F;x-www-form-urlencoded<br>Access-Control-Allow-Methods: GET,POST,OPTIONS<br>Content-Length: 49  </p>
<p>{“resultCode”:1,”resultMsg”:”手机号未注册”}   &#x2F;&#x2F;正文</p>
</li>
</ol>
<h3 id="1-状态行"><a href="#1-状态行" class="headerlink" title="1.状态行"></a>1.状态行</h3><p>由<strong>协议版本</strong>、数字形式的<strong>状态代码</strong>、及相应的<strong>状态描述</strong>，各元素之间以空格分隔。</p>
<ul>
<li>状态描述： 状态描述给出了关于状态代码的简短的文字描述。</li>
<li>状态代码：  状态代码由3位数字组成，表示请求是否被理解或被满足。</li>
</ul>
<p>状态代码的第一个数字定义了响应的类别，后面两位没有具体的分类。<br>第一个数字有五种可能的取值：</p>
<ul>
<li>1xx:   指示信息—表示请求已接收，继续处理。</li>
<li>2xx:   成功—表示请求已经被成功接收、理解、接受。</li>
<li>3xx:   重定向—要完成请求必须进行更进一步的操作。</li>
<li>4xx:   客户端错误—请求有语法错误或请求无法实现。</li>
<li>5xx: 服务器端错误—服务器未能实现合法的请求。</li>
</ul>
<p>状态代码 状态描述    说明</p>
<ul>
<li>200  OK    客户端请求成功  </li>
<li>400  Bad Request   由于客户端请求有语法错误，不能被服务器所理解。  </li>
<li>401  Unauthonzed   请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用  </li>
<li>403   Forbidden   服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因  </li>
<li>404   Not Found   请求的资源不存在，例如，输入了错误的URL。  </li>
<li>500  Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。  </li>
<li>503  Service Unavailable   服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</li>
</ul>
<h3 id="2-响应头"><a href="#2-响应头" class="headerlink" title="2.响应头"></a>2.响应头</h3><p>响应头可能包括：</p>
<ul>
<li>Content-Type :指明发送给接收者的实体正文的媒体类型。如：Content-Type: text&#x2F;html;charset&#x3D;ISO-8859-1Content-Type: text&#x2F;html;charset&#x3D;GB2312  </li>
<li>Content-Language：源所用的自然语言</li>
<li>Content-Length：指明正文的长度，</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/05/Http%E8%A7%A3%E6%9E%90/" data-id="cl4gp6u1n000k9cvcgayd0k3q" data-title="HTTP解析" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-一. 多线程编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/03/%E4%B8%80.%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2018-03-03T10:44:15.000Z" itemprop="datePublished">2018-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/03/%E4%B8%80.%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/">多线程编程技术</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一，多线程基础及概念"><a href="#一，多线程基础及概念" class="headerlink" title="一，多线程基础及概念"></a>一，多线程基础及概念</h2><h3 id="1-线程和进程"><a href="#1-线程和进程" class="headerlink" title="1. 线程和进程"></a>1. 线程和进程</h3><p>可以将运行在内存中的exe文件理解成进程，进程是受操作系统管理的基本运行单元。<br>线程可以理解成是在进程中独立运行的子任务。</p>
<p>单任务特点是排队执行，也就是同步。缺点是cpu利用率大幅降低。</p>
<p>一个进程在运行时至少会有一个线程在运行。</p>
<h3 id="2-线程实现的两种方式"><a href="#2-线程实现的两种方式" class="headerlink" title="2. 线程实现的两种方式"></a>2. 线程实现的两种方式</h3><p>一种是继承Thread类，另一种是实现Runnable接口。他们之间具有多态关系。使用继承Thread时，最大的局限是不支持多继承，为了支持多继承，可以实现Runnable接口。</p>
<h4 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 继承Thread类</h4><pre><code>public class MyThread extends Thread&#123;
    @override
    public void run()&#123;
        super.run();
        System.out.println(&quot;myThread&quot;);
    &#125;
&#125;

运行代码如下：

public class Run&#123;
    public static void main(String[] args)&#123;
        MyThread mythread = new MyThread();
        mythread.start();
        System.out.println(&quot;运行结束&quot;);
    &#125;
&#125;

代码执行顺序和运行顺序是无关的。
</code></pre>
<h4 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h4><pre><code>public class MyRunnable implements Runnable &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;运行中&quot;);
    &#125;
&#125;

运行代码：

public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
       Runnable runnable = new MyRunnable();
       Thread thread  = new Thread(runnable);
       thread.start();
        System.out.println(&quot;运行结束&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="3-实例变量与线程安全"><a href="#3-实例变量与线程安全" class="headerlink" title="3. 实例变量与线程安全"></a>3. 实例变量与线程安全</h3><p>线程针对变量有共享和不共享之分，这在交互时是很重要的一个技术点。</p>
<h4 id="3-1-不共享数据的情况"><a href="#3-1-不共享数据的情况" class="headerlink" title="3.1 不共享数据的情况"></a>3.1 不共享数据的情况</h4><pre><code>代码如下
public class MyThread extends Thread &#123;
    private int count=5;
    public MyThread(String name)&#123;
        super();
        this.setName(name);
    &#125;
    @Override
    public void run() &#123;
        super.run();
        while (count&gt;0)&#123;
            count--;
            System.out.println(&quot;由&quot;+this.currentThread().getName()+&quot; 计算，count=&quot;+count);
        &#125;
    &#125;
&#125;

public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
       MyThread a = new MyThread(&quot;a&quot;);
       MyThread b = new MyThread(&quot;b&quot;);
       MyThread c = new MyThread(&quot;c&quot;);
       a.start();
       b.start();
       c.start();
    &#125;
&#125;
运行效果如下:
由c 计算，count=4
由c 计算，count=3
由c 计算，count=2
由c 计算，count=1
由c 计算，count=0
由b 计算，count=4
由b 计算，count=3
由b 计算，count=2
由b 计算，count=1
由b 计算，count=0
由a 计算，count=4
由a 计算，count=3
由a 计算，count=2
由a 计算，count=1
由a 计算，count=0
</code></pre>
<p>这种情况是变量不共享</p>
<h4 id="3-2-共享数据的情况"><a href="#3-2-共享数据的情况" class="headerlink" title="3.2 共享数据的情况"></a>3.2 共享数据的情况</h4><p>多个线程可以访问同一个变量 </p>
<pre><code>代码如下
public class MyThread extends Thread &#123;
    private int count = 5;
    @Override
    public void run() &#123;
        super.run();
        count--;
        System.out.println(&quot;由&quot; + this.currentThread().getName() + &quot; 计算，count=&quot; + count);
    &#125;
&#125;
public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
       MyThread myThread = new MyThread();
       Thread a = new Thread(myThread,&quot;A&quot;);
       Thread b = new Thread(myThread,&quot;B&quot;);
       Thread c = new Thread(myThread,&quot;C&quot;);
       Thread d = new Thread(myThread,&quot;D&quot;);
       Thread e = new Thread(myThread,&quot;E&quot;);
       a.start();
       b.start();
       c.start();
       d.start();
       e.start();
    &#125;
&#125;
运行效果如下：
由E 计算，count=2
由A 计算，count=4
由C 计算，count=3
由D 计算，count=0
由B 计算，count=0
</code></pre>
<p>可以看出对A，B同时对count进行处理。产生了非线程安全问题。这不是我们想要的结果。</p>
<p>要解决些问题，只需要要在run方法前加入synchronized关键字，使多线程在执行run 方法时，以排队的方式进行处理。</p>
<pre><code>public class MyThread extends Thread &#123;
    private int count = 5;
    @Override
    synchronized public void run() &#123;
        super.run();
        count--;
        System.out.println(&quot;由&quot; + this.currentThread().getName() + &quot; 计算，count=&quot; + count);
    &#125;
&#125;
</code></pre>
<p>synchronized说明对此该当上了锁，上了锁，当有线程正在运行此方法时，必须等待其他线程对run线程调用结束后才可执行。</p>
<p>synchronized可以在任意对象及方法上加锁，而加锁这段代码称为 互斥区 或者 临界区</p>
<blockquote>
<p>非线程安全： 主要是指多个线程对同一个对象中的同一个变量进行操作时会出现值被更改，值不同步的情况，进而影响程序的执行流程。</p>
</blockquote>
<p>如下是一个非线程安全的Demo,觉得不错：</p>
<pre><code>public class LoginServlet &#123;
    private static String username;
    private static String password;
    public static void post(String username1, String password1) &#123;
        try &#123;
            username = username1;
            if (username.equals(&quot;a&quot;)) &#123;
                Thread.sleep(2000);
            &#125;
            password = password1;
            System.out.println(&quot;username = &quot; + username + &quot;  password = &quot; + password);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

public class ALogin extends Thread&#123;
    @Override
    public void run() &#123;
        LoginServlet.post(&quot;a&quot;,&quot;aa&quot;);
    &#125;
&#125;

public class BLogin extends Thread &#123;
    @Override
    public void run() &#123;
        LoginServlet.post(&quot;b&quot;,&quot;bb&quot;);
    &#125;
&#125;

public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ALogin aLogin = new ALogin();
        aLogin.start();
        BLogin bLogin = new BLogin();
        bLogin.start();
    &#125;
&#125;
运行结果：
username = b  password = bb
username = b  password = aa

解决这个非线程安全的问题也是使用synchronized

synchronized public class LoginServlet &#123;
    private static String username;
    private static String password;
    public static void post(String username1, String password1) &#123;
        try &#123;
            username = username1;
            if (username.equals(&quot;a&quot;)) &#123;
                Thread.sleep(2000);
            &#125;
            password = password1;
            System.out.println(&quot;username = &quot; + username + &quot;  password = &quot; + password);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="4-线程常用方法"><a href="#4-线程常用方法" class="headerlink" title="4 线程常用方法"></a>4 线程常用方法</h3><h4 id="currentThread-方法"><a href="#currentThread-方法" class="headerlink" title="currentThread()方法"></a>currentThread()方法</h4><p>方法返回代码段正常被哪个线程调用的信息。</p>
<p>demo如下</p>
<pre><code>public class CountOperate extends Thread &#123;
    public CountOperate()&#123;
        System.out.println(&quot;begin&quot;);
        System.out.println(Thread.currentThread().getName());
        System.out.println(this.getName());
        System.out.println(&quot;end&quot;);
    &#125;

    @Override
    public void run() &#123;
        System.out.println(&quot;be&quot;);
        System.out.println(Thread.currentThread().getName());
        System.out.println(this.getName());
        System.out.println(&quot;en&quot;);
    &#125;
&#125;

public class Main &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        CountOperate countOperate = new CountOperate();
        Thread thread = new Thread(countOperate);
        thread.setName(&quot;A&quot;);
        thread.start();
    &#125;
&#125;
运行结果如下：
begin
main
Thread-0
end
be
A
Thread-0
en
</code></pre>
<p>结果说明：<br>构造方法CountOperate被main线程调用，<br>run方法是被名叫A的线程调用的</p>
<h4 id="isAlive-方法"><a href="#isAlive-方法" class="headerlink" title="isAlive()方法"></a>isAlive()方法</h4><p>功能是判断当前的线程是否处于活跃状态。</p>
<p>活跃状态是指线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态，就认为线程是存活的。</p>
<h4 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h4><p>作用是指在指定的毫秒数内让当前 正在执行的线程 休眠（暂停执行）。<br>这个 正在执行的线程是指this.currentThread()返回的线程</p>
<h4 id="getId-方法"><a href="#getId-方法" class="headerlink" title="getId()方法"></a>getId()方法</h4><p>作用是取得线程的唯一标识。</p>
<h4 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h4><p>使用是放弃当前的cpu资源，</p>
<h3 id="5-停止线程"><a href="#5-停止线程" class="headerlink" title="5 停止线程"></a>5 停止线程</h3><p>java 有三种方法能停止线程</p>
<ol>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li>
<li>停止线程可以使用Thread.stop()方法，方法不安全，且已废弃</li>
<li>可用Thread.interrupt()方法，方法不会终止正在运行的线程，还需要加入一个判断才能完成线程的停止</li>
</ol>
<h4 id="5-1-判断线程是否停止状态"><a href="#5-1-判断线程是否停止状态" class="headerlink" title="5.1 判断线程是否停止状态"></a>5.1 判断线程是否停止状态</h4><p>判断线程状态是不是停止的。有两种方法</p>
<ol>
<li><p>this.interrupted(): 测试当前线程是否已经中断,执行后具有将状态标志清除为false的功能</p>
</li>
<li><p>this.isInterrupted(): 测试线程是否已经中断，但不清除状态标志</p>
<p>public class Mythread extends Thread {<br>private long i  &#x3D;0;<br>@Override<br>public void run() {<br>    for (int j &#x3D; 0; j &lt; 5000; j++) {<br>        System.out.println(“j &#x3D; “+j);<br>    }<br>}<br>}</p>
<p>public class Main {<br>public static void main(String[] args) {<br>    try {<br>        Mythread mythread &#x3D; new Mythread();<br>        mythread.start();<br>        Thread.sleep(1000);<br>        mythread.interrupt();<br>        System.out.println(“是否停止1 &#x3D; “+mythread.interrupted());<br>        System.out.println(“是否停止2 &#x3D; “+mythread.interrupted());<br>    } catch (Exception e) {<br>        e.printStackTrace();<br>    }<br>}<br>}</p>
<p>运行结果<br>j &#x3D; 4998<br>j &#x3D; 4999<br>是否停止1 &#x3D; false<br>是否停止2 &#x3D; false</p>
<p>打印两个false,这个当前线程是main,从未中断过,所以打印的结果是两个 false.</p>
</li>
</ol>
<p>如何使main 线程产生中断效果呢</p>
<pre><code>public class MainDemo &#123;
    public static void main(String[] args) &#123;
        Thread.currentThread().interrupt();
        System.out.println(Thread.interrupted());
        System.out.println(Thread.interrupted());
        System.out.println(&quot;end&quot;);
    &#125;
&#125;
运行结果:
true
false
end
</code></pre>
<h4 id="5-2-能停止的线程-异常法"><a href="#5-2-能停止的线程-异常法" class="headerlink" title="5.2 能停止的线程-异常法"></a>5.2 能停止的线程-异常法</h4><pre><code>public class Mythread extends Thread &#123;
    @Override
    public void run() &#123;
        try &#123;
            for (int j = 0; j &lt; 500000; j++) &#123;
                if(this.interrupted())&#123;
                    System.out.println(&quot;已经是停止状态了，我要退出了&quot;);
                    throw new InterruptedException();
                &#125;
                System.out.println(&quot;j = &quot;+j);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            System.out.println(&quot;进入Mythered.java类run方法中的catch了&quot;);
            e.printStackTrace();
        &#125;
    &#125;
&#125;

public class Main &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Mythread mythread = new Mythread();
            mythread.start();
            Thread.sleep(2000);
            mythread.interrupt();
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;main catch&quot;);
            e.printStackTrace();
        &#125;
        System.out.println(&quot;end&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="5-3-在沉睡中停止"><a href="#5-3-在沉睡中停止" class="headerlink" title="5.3 在沉睡中停止"></a>5.3 在沉睡中停止</h4><h4 id="5-4-stop-暴力停止"><a href="#5-4-stop-暴力停止" class="headerlink" title="5.4 stop()暴力停止"></a>5.4 stop()暴力停止</h4><h4 id="5-5-使用return停止线程"><a href="#5-5-使用return停止线程" class="headerlink" title="5.5 使用return停止线程"></a>5.5 使用return停止线程</h4><p>总结,还是建议使用 抛异常法来实现线程的停止.因为在catch块中还可以将异常向上抛.</p>
<h3 id="6-暂停线程"><a href="#6-暂停线程" class="headerlink" title="6 暂停线程"></a>6 暂停线程</h3><p>暂停线程意味着还可以恢复运行，在java多线程中，可以 使用suspend()方法暂停线程，使用resume()方法恢复线程的执行。</p>
<h4 id="6-1-suspend与resume-方法的缺点-独占"><a href="#6-1-suspend与resume-方法的缺点-独占" class="headerlink" title="6.1 suspend与resume 方法的缺点-独占"></a>6.1 suspend与resume 方法的缺点-独占</h4><p>在使用suspend 与resume 方法时，如果使用不当，极易造成公共的同步对象的独占，使得其他线程无法访问公共同步对象。</p>
<h4 id="6-2-suspend与resume方法的缺点-不同步"><a href="#6-2-suspend与resume方法的缺点-不同步" class="headerlink" title="6.2 suspend与resume方法的缺点-不同步"></a>6.2 suspend与resume方法的缺点-不同步</h4><p>在使用suspend与resume方法时也容易出现因为线程的暂停而导致数据不同步的情况 </p>
<h3 id="7-线程的优先级"><a href="#7-线程的优先级" class="headerlink" title="7 线程的优先级"></a>7 线程的优先级</h3><p>线程可以划分优先级，优先级高的线程得到的CPU资源多，</p>
<p>线程划分为1-10这10个等级，如果小于1或大于10，则JDK抛出异常 throw new IllegalArgumentException() ,jdk使用3 个常量来预置定义优先级。</p>
<pre><code>public final static int MIN_PRIORITY = 1;

public final static int NORM_PRIORITY = 5;

public final static int MAX_PRIORITY = 10;
</code></pre>
<h4 id="7-1-线程优先级具有继承特性"><a href="#7-1-线程优先级具有继承特性" class="headerlink" title="7.1 线程优先级具有继承特性"></a>7.1 线程优先级具有继承特性</h4><p>比如A线程启动线程B,则B线程的优先级和A是一样的。</p>
<p>代码如下：</p>
<pre><code>public class Mythread1 extends Thread &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;Mythread1 run priority = &quot;+this.getPriority());
        Mythread2 mythread2 = new Mythread2();
        mythread2.start();
    &#125;
&#125;

public class Mythread2 extends Thread &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;Mythread2 run priority=&quot;+this.getPriority());
    &#125;
&#125;

public class Main &#123;
    public static void main(String[] args) &#123;
        System.out.println(Thread.currentThread().getName()+&quot; thread begin = &quot;+Thread.currentThread().getPriority());
        Thread.currentThread().setPriority(7);
        System.out.println(Thread.currentThread().getName()+&quot; thread end = &quot;+Thread.currentThread().getPriority());
        Mythread1 mythread1 = new Mythread1();
        mythread1.start();
    &#125;
&#125;

运行结果：
main thread begin = 5
main thread end = 7
Mythread1 run priority = 7
Mythread2 run priority=7
</code></pre>
<h4 id="7-2-优先级具有规则性"><a href="#7-2-优先级具有规则性" class="headerlink" title="7.2 优先级具有规则性"></a>7.2 优先级具有规则性</h4><p>高优先级的线程就是大部分先执行完，但并不代表优先级高的线程全部先执行完。当线程优先级差别很大时，谁先报告完和代码的<strong>调用顺序无关</strong>。也就是说cpu尽量将执行资源让给优先级比较高的线程。</p>
<h4 id="7-3-优先级具有随机性"><a href="#7-3-优先级具有随机性" class="headerlink" title="7.3 优先级具有随机性"></a>7.3 优先级具有随机性</h4><p>线程的优先级高则优先执行完run（）中的方法,但这个结果不能说的太肯定。因为线程优先级还具有随机性，也就是说优先级较高的线程不一定每次都先执行完。</p>
<p>不要把线程的优先级与运行结果的顺序作为衡量的标准。优先级高的线程并不一定每一次都先执行完run()中的方法，也就是说优先极与打印顺序无关。</p>
<h3 id="8-守护线程"><a href="#8-守护线程" class="headerlink" title="8 守护线程"></a>8 守护线程</h3><p>在java中有两种线程：</p>
<ul>
<li>用户线程</li>
<li>守护线程 有陪伴的含义，当进程中不存在非守护线程了则守护线程自动销毁。比如垃圾守护线程。任何一个守护线程就是整个JVM中守护线程的保姆。只要非守护线程没有结束，守护线程就在工作。最典型的应用就是GC（垃圾回收器）</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇只是简单的介绍。后续陆续更新中……敬请期待</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/03/%E4%B8%80.%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" data-id="cl4gp6u2l002o9cvcg6mr62k1" data-title="多线程编程技术" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-经典句子" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/05/09/%E7%BB%8F%E5%85%B8%E5%8F%A5%E5%AD%90/" class="article-date">
  <time class="dt-published" datetime="2016-05-09T15:20:07.000Z" itemprop="datePublished">2016-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/05/09/%E7%BB%8F%E5%85%B8%E5%8F%A5%E5%AD%90/">经典句子</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>宁惹白头翁，莫欺少年郎</p>
<p>灵魂的孤独比经济拮据更可怕</p>
<p>灵魂的贫穷是无法补救的，你该问自己真正想要的是什么 ，愿你不再错过，愿你不再将就</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2016/05/09/%E7%BB%8F%E5%85%B8%E5%8F%A5%E5%AD%90/" data-id="cl4gp6u2z003u9cvc6r1h7tv1" data-title="经典句子" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-IBM rose 工具的使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/04/24/IBM%20rose%20%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2016-04-23T23:45:51.000Z" itemprop="datePublished">2016-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/04/24/IBM%20rose%20%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">IBM rose工具的使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>第一次装上 IBM rose这个工具，出现了 </p>
<p>解决无法启动此程序因为丢失suite objects.dll  这个错误，</p>
<p>通过配置环境变量即可解决这个问题，</p>
<p>把rose安装路径下的  E:\software\rose\Common  路径添加 到 path 环境变量 中即可</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2016/04/24/IBM%20rose%20%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="cl4gp6u1m000i9cvc7z6n30d6" data-title="IBM rose工具的使用" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-oracle decode grouping统计分组查询" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/04/12/oracle%20decode%20grouping%E7%BB%9F%E8%AE%A1%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/" class="article-date">
  <time class="dt-published" datetime="2016-04-12T05:43:49.000Z" itemprop="datePublished">2016-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/04/12/oracle%20decode%20grouping%E7%BB%9F%E8%AE%A1%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/">oracle decode grouping rollup cube统计分组查询</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>学习所用表为</p>
<pre><code>create table student(
nianji varchar(20),
banji varchar(20),
math varchar(20),
english varchar(20)
);

插入测试数据
insert into  student values (&#39;1&#39;,&#39;1&#39;,&#39;100&#39;,&#39;87&#39;); 
insert into  student values (&#39;1&#39;,&#39;2&#39;,&#39;100&#39;,&#39;76&#39;); 
insert into  student values (&#39;1&#39;,&#39;3&#39;,&#39;48&#39;,&#39;26&#39;); 
insert into  student values (&#39;2&#39;,&#39;1&#39;,&#39;75&#39;,&#39;86&#39;); 
insert into  student values (&#39;2&#39;,&#39;2&#39;,&#39;67&#39;,&#39;87&#39;); 
insert into  student values (&#39;2&#39;,&#39;3&#39;,&#39;96&#39;,&#39;65&#39;); 

insert into  student values (&#39;1&#39;,&#39;1&#39;,&#39;100&#39;,&#39;100&#39;); 
insert into  student values (&#39;1&#39;,&#39;2&#39;,&#39;100&#39;,&#39;100&#39;); 
insert into  student values (&#39;1&#39;,&#39;3&#39;,&#39;100&#39;,&#39;100&#39;); 
insert into  student values (&#39;2&#39;,&#39;1&#39;,&#39;100&#39;,&#39;100&#39;); 
insert into  student values (&#39;2&#39;,&#39;2&#39;,&#39;100&#39;,&#39;100&#39;); 
insert into  student values (&#39;2&#39;,&#39;3&#39;,&#39;100&#39;,&#39;100&#39;); 
</code></pre>
<h3 id="oracle-rollup和cube-，grouping-sets-函数的使用"><a href="#oracle-rollup和cube-，grouping-sets-函数的使用" class="headerlink" title="oracle rollup和cube ，grouping sets 函数的使用"></a>oracle rollup和cube ，grouping sets 函数的使用</h3><p><strong>rollup</strong></p>
<h4 id="向ROLLUP传递一列"><a href="#向ROLLUP传递一列" class="headerlink" title="向ROLLUP传递一列"></a>向ROLLUP传递一列</h4><pre><code>select banji,sum(english) from student group by rollup(banji);

1	373
2	363
3	291
    1027
</code></pre>
<p>通过用rollup可以自动加一列，最后一列为自动加上的</p>
<h4 id="向ROLLUP传递多列"><a href="#向ROLLUP传递多列" class="headerlink" title="向ROLLUP传递多列"></a>向ROLLUP传递多列</h4><pre><code>select nianji,banji,sum(english) from student group by rollup(nianji,banji);

1	1	187
1	2	176
1	3	126
1		489
2	1	186
2	2	187
2	3	165
2		538
        1027

可以看到，除了在最后有一个求和记录外，每个 jianji,banji 分组也会有一个求和记录。
</code></pre>
<p>那么我们现在交换一下ROLLUP中数据列的顺序，看看结果怎样</p>
<pre><code>select nianji,banji,sum(english) from student group by rollup(banji,nianji);

1	1	187
2	1	186
    1	373
1	2	176
2	2	187
    2	363
1	3	126
2	3	165
    3	291
        1027
两者效果很显示，不用我多说了吧
</code></pre>
<p>rollup 原理如下，也只不过是用了 union all 运算符而已</p>
<blockquote>
<p>假设有一个表test，有A、B、C、D、E5列。<br>如果使用group by rollup(A,B,C)，首先会对(A、B、C)进行GROUP BY，然后对(A、B)进行GROUP BY，然后是(A)进行GROUP BY，最后对全表进行GROUP BY操作。roll up的意思是“卷起”，这也可以帮助我们理解group by rollup就是对选择的列从右到左以一次少一列的方式进行grouping直到所有列都去掉后的grouping(也就是全表grouping)，对于n个参数的rollup，有n+1次的grouping。以下2个sql的结果集是一样的：</p>
</blockquote>
<pre><code>Select A,B,C,sum(E) from test group by rollup(A,B,C)
与
Select A,B,C,sum(E) from test group by A,B,C
union all
Select A,B,null,sum(E) from test group by A,B
union all
Select A,null,null,sum(E) from test group by A
union all
Select null,null,null,sum(E) from test
</code></pre>
<p>和下列代码一样的效果</p>
<pre><code>select nianji,banji,sum(english) from student group by nianji,banji union all
select nianji,null,sum(english) from student group by nianji union all
select null,null,sum(english) from student order by nianji

1	3	126
1		489
1	1	187
1	2	176
2	1	186
2	2	187
2	3	165
2		538
        1027
</code></pre>
<h4 id="向CUBE传递一列"><a href="#向CUBE传递一列" class="headerlink" title="向CUBE传递一列"></a>向CUBE传递一列</h4><pre><code>select banji,sum(math) from student group by cube(banji) order by banji;

1	373
2	323
3	344
    1040
</code></pre>
<p>好像没什么不一样，别急，往下看</p>
<h4 id="向CUBE传递多列"><a href="#向CUBE传递多列" class="headerlink" title="向CUBE传递多列"></a>向CUBE传递多列</h4><pre><code>select nianji,banji,sum(english) from student group by cube(nianji,banji) order by nianji,banji;

1	1	187
1	2	176
1	3	126
1		489
2	1	186
2	2	187
2	3	165
2		538
    1	373
    2	363
    3	291
        1027
大家看出有什么不一样了吗，看最后一列.根据nianji统计分数，根据banji统计分数，
</code></pre>
<p>cube原理如下</p>
<blockquote>
<p>cube的意思是立方，对cube的每个参数，都可以理解为取值为参与grouping和不参与grouping两个值的一个维度，然后所有维度取值组合的集合就是grouping的集合，对于n个参数的cube，有2^n次的grouping。如果使用group by cube(A,B,C),，则首先会对(A、B、C)进行GROUP BY，然后依次是(A、B)，(A、C)，(A)，(B、C)，(B)，(C)，最后对全表进行GROUP BY操作，一共是2^3&#x3D;8次grouping。同rollup一样，也可以用基本的group by加上结果集的union all写出一个与group by cube结果集相同的sql：</p>
</blockquote>
<pre><code>Select A,B,C,sum(E) from test group by cube(A,B,C);
与
Select A,B,C,sum(E) from test group by A,B,C
union all
Select A,B,null,sum(E) from test group by A,B
union all
Select A,null,C,sum(E) from test group by A,C
union all
Select A,null,null,sum(E) from test group by A
union all
Select null,B,C,sum(E) from test group by B,C
union all
Select null,B,null,sum(E) from test group by B
union all
Select null,null,C,sum(E) from test group by C
union all
Select null,null,null,sum(E) from test;
</code></pre>
<p>和下列代码产生一样的效果 </p>
<pre><code>select nianji,banji,sum(english) from student group by nianji,banji union all
select nianji,null,sum(english) from student group by nianji union all
select null,banji,sum(english) from student group by banji union all
select null,null,sum(english) from student ;

1	1	187
2	2	187
2	1	186
1	2	176
2	3	165
1	3	126
1		489
2		538
    1	373
    3	291
    2	363
        1027
</code></pre>
<h4 id="grouping-sets"><a href="#grouping-sets" class="headerlink" title="grouping sets"></a>grouping sets</h4><blockquote>
<p>grouping sets就是对参数中的每个参数做grouping，也就是有几个参数做几次grouping,例如使用group by grouping sets(A,B,C)，则对(A),(B),(C)进行group by，如果使用group by grouping sets((A,B),C),则对(A,B),(C)进行group by。甚至grouping by grouping set(A,A)都是语法允许的，也就是对(A)进行2次group by,grouping sets的参数允许重复</p>
</blockquote>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><strong>机制不同</strong> – 在rollup和cube的说明中分别给出了用基本group by加结果集union all给出了结果集相同的sql，但这只是为了理解的方便而给出的sql，并不说明rollup和cube与基本group by加结果集union all等价。实际上两者的内部机制是安全不一样的，前者除了写法简洁以外，运行时不需多次扫描表，效率远比后者高。</li>
<li><strong>集合可运算</strong> –3种扩展用法的参数可以是源表中的某一个具体的列，也可以是若干列经过计算而形成的一个新列（比如说A+B，A||B），也可以是这两种列的一个集合（例如（A+B，C）），对于grouping set更是特殊，可以是空集合()，表示对全表进行group by。</li>
<li><strong>group by 与 rollup, cube组合使用</strong> –</li>
</ul>
<h3 id="oracle-grouping-函数的使用"><a href="#oracle-grouping-函数的使用" class="headerlink" title="oracle grouping 函数的使用"></a>oracle grouping 函数的使用</h3><h4 id="grouping"><a href="#grouping" class="headerlink" title="grouping()"></a>grouping()</h4><p>参数只有一个，而且必须为group by中出现的某一列，表示结果集的一行是否对该列做了grouping。对于对该列做了grouping的行而言，grouping()&#x3D;0，反之为1；</p>
<blockquote>
<p>GROUPING函数可以接受一列，返回0或者1。如果列值为空，那么GROUPING()返回1；如果列值非空，那么返回0。GROUPING只能在使用ROLLUP或CUBE的查询中使用。当需要在返回空值的地方显示某个值时，GROUPING()就非常有用。</p>
</blockquote>
<h4 id="grouping-id"><a href="#grouping-id" class="headerlink" title="grouping_id()"></a>grouping_id()</h4><p>参数可以是多个，但必须为group by中出现的列。Grouping_id()的返回值其实就是参数中的每列的grouping()值的二进制向量，例如如果grouping(A)&#x3D;1，grouping(B)&#x3D;0，则grouping_id(A,B)的返回值就是二进制的10，转成10进制就是2。</p>
<h4 id="group-id"><a href="#group-id" class="headerlink" title="group_id()"></a>group_id()</h4><p>无参数。见上面的说明3），group by对某些列的集合会进行重复的grouping，而实际上绝大多数情况下对结果集中的这些重复行是不需要的，那就必须有办法剔出这些重复grouping的行。当结果集中有n条重复grouping而形成的行时，每行的group_id()分别是0,1,…,n，这样我们在条件中加入一个group_id()&lt;1就可以剔出这些重复grouping的行了。</p>
<h4 id="在ROLLUP中对单列使用GROUPING"><a href="#在ROLLUP中对单列使用GROUPING" class="headerlink" title="在ROLLUP中对单列使用GROUPING()"></a>在ROLLUP中对单列使用GROUPING()</h4><pre><code>select grouping(banji),banji,sum(english) from student group by rollup(banji);

0	1	373
0	2	363
0	3	291
1		1027
</code></pre>
<h4 id="使用CASE转换GROUPING-的返回值"><a href="#使用CASE转换GROUPING-的返回值" class="headerlink" title="使用CASE转换GROUPING()的返回值"></a>使用CASE转换GROUPING()的返回值</h4><pre><code>select case grouping(banji) when 1 then &#39;总计&#39; else banji end as div ,sum(english) from student group by rollup(banji);

1	373
2	363
3	291
总计	1027
</code></pre>
<h3 id="oracle中的decode-函数的使用"><a href="#oracle中的decode-函数的使用" class="headerlink" title="oracle中的decode 函数的使用"></a>oracle中的decode 函数的使用</h3><p>上次是用case来转换值 ，这次来使用decode，</p>
<pre><code>select decode (grouping(banji),1,&#39;总计&#39;,banji), sum(english) from student group by rollup(banji);

1	373
2	363
3	291
总计	1027

看到了吧，效果是一样的，用这个函数更好些


select decode (grouping(banji),1,&#39;总计&#39;,&#39;0&#39;,banji), sum(english) from student group by rollup(banji);

1	373
2	363
3	291
总计	1027

我如果这样写效果是一样的
</code></pre>
<p>我们继续往下走</p>
<pre><code>select grouping(nianji),grouping(banji), sum(english) from student group by rollup(banji,nianji);

0	0	187
0	0	176
0	0	126
0	1	489
0	0	186
0	0	187
0	0	165
0	1	538
1	1	1027

你发现了什么，是不是有什么规律呢


select decode(grouping(nianji),0,nianji,1,&#39;总计&#39;),decode(grouping(banji),0,banji,1,&#39;总计&#39;), sum(english) from student group by rollup(nianji,banji);

1	1	187
1	2	176
1	3	126
1	总计	489
2	1	186
2	2	187
2	3	165
2	总计	538
总计	总计	1027

到这你是不是已经知道decode怎么用了，不过这还不是我想要的，

select  decode(grouping(nianji)+grouping(banji),1,&#39;年级总分&#39;,2,&#39;总计&#39;,nianji) 年级,
decode(grouping(banji)+grouping(nianji),1,&#39;班级总计&#39;,2,&#39;总计&#39;,banji) 班级,sum(math) 数学成绩,sum(english ) 英语成绩
from student
group by rollup(nianji,banji) ;

1	1	198	187
1	2	156	176
1	3	148	126
年级总分	班级总计	502	489
2	1	175	186
2	2	167	187
2	3	196	165
年级总分	班级总计	538	538
总计	总计	1040	1027

好了，到这就结束了，这就是我要的效果，是不是感觉sql很强大，用法就是这么写的，下面来看下语法 
</code></pre>
<p>结合上面的sql，你再看语法将会变得非常简单，通俗易懂。</p>
<p><strong>decode语法</strong></p>
<pre><code>decode(条件,值1,返回值1,值2,返回值2,...值n,返回值n,缺省值)
该函数的含义如下：
IF 条件=值1 THEN
　　　　RETURN(翻译值1)
ELSIF 条件=值2 THEN
　　　　RETURN(翻译值2)
　　　　......
ELSIF 条件=值n THEN
　　　　RETURN(翻译值n)
ELSE
　　　　RETURN(缺省值)
END IF
decode(字段或字段的运算，值1，值2，值3）
</code></pre>
<p> 这个函数运行的结果是，当字段或字段的运算的值等于值1时，该函数返回值2，否则返回值3<br>当然值1，值2，值3也可以是表达式，这个函数使得某些sql语句简单了许多，结合上面的例子，是不是变得简单明了。</p>
<p>爱学习，爱编程，爱挑战，爱钻研。</p>
<p>如果你觉的好，对你有帮助就，捐助1分钱吧，以资鼓励<br><img src="http://7xpw00.com1.z0.glb.clouddn.com/1460449579392.jpg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2016/04/12/oracle%20decode%20grouping%E7%BB%9F%E8%AE%A1%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/" data-id="cl4gp6u2600209cvcd8nd33bm" data-title="oracle decode grouping rollup cube统计分组查询" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Error/" rel="tag">Error</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Extjs/" rel="tag">Extjs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/" rel="tag">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PowerDesigner/" rel="tag">PowerDesigner</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">java虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/myeclipse%E6%8F%92%E4%BB%B6/" rel="tag">myeclipse插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E8%AE%B0/" rel="tag">日记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%AE%B0/" rel="tag">杂记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB%E6%96%87%E5%8C%96%E4%B8%8E%E7%B4%A0%E5%85%BB/" rel="tag">生活文化与素养</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Extjs/" style="font-size: 10px;">Extjs</a> <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/PowerDesigner/" style="font-size: 12.86px;">PowerDesigner</a> <a href="/tags/Spring/" style="font-size: 14.29px;">Spring</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 12.86px;">java虚拟机</a> <a href="/tags/linux/" style="font-size: 17.14px;">linux</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/myeclipse%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">myeclipse插件</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 14.29px;">工具</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 18.57px;">数据库</a> <a href="/tags/%E6%97%A5%E8%AE%B0/" style="font-size: 15.71px;">日记</a> <a href="/tags/%E6%9D%82%E8%AE%B0/" style="font-size: 14.29px;">杂记</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 14.29px;">框架</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E6%96%87%E5%8C%96%E4%B8%8E%E7%B4%A0%E5%85%BB/" style="font-size: 11.43px;">生活文化与素养</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 12.86px;">笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/16/Hexo-github-%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/">Hexo+github搭建静态博客(新手入门)</a>
          </li>
        
          <li>
            <a href="/2022/06/14/test/">test</a>
          </li>
        
          <li>
            <a href="/2022/06/14/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/04/20/%E4%BA%94.%20volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/">五. volatile关键字</a>
          </li>
        
          <li>
            <a href="/2018/04/19/%E4%B8%89.%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">三. 垃圾收集器</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Zhutongtong<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>